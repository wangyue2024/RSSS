
# RSSS (Rust Stock Simulation System) - 完整技术架构与实施白皮书 v1.2

## 1. 项目愿景与定位 (Vision)

RSSS 是一个基于 Rust 语言构建的 **高性能、微观结构仿真、事件驱动型计算金融系统** 。
它旨在单机环境下，利用 Rust 的零成本抽象（Zero-Cost Abstraction）能力，模拟 **1000+ 个由 LLM 生成的异构智能体 (Agents)** 在连续时间流下的博弈行为，以观察市场微观结构的涌现现象（Emergent Behavior）。

### 核心差异化优势 (Interview Highlights)

* **混合运行时 (Hybrid Runtime)** : Rust 负责重计算与并发调度，Rhai 脚本负责策略逻辑，兼顾性能与灵活性。
* **确定性并发 (Deterministic Concurrency)** : 即使在多线程并行计算下，通过基于种子的 RNG 管理，实现回测结果的比特级可复现。
* **微观高保真** : 模拟了网络延迟（随机乱序）、滑点（Slippage）、流动性枯竭等真实市场特征。
* **工业级工程化** : 采用多二进制架构（生成器/模拟器分离），实现 IO 隔离（异步落盘），并严格遵循定点数算术标准。

## 2. 核心设计哲学 (Methodologies)

### 2.1 定点数精度模型 (Fixed-Point Arithmetic)

* **背景** : 金融计算严禁使用 `f64`，因为 IEEE 754 浮点数存在精度丢失（如 `0.1 + 0.2 != 0.3`）。
* **实现** : 全系统采用 `i64` 存储微元 (Micros)。
* **标准** : `SCALING_FACTOR = 1_000_000`。
* 逻辑值 `100.50` -> 物理存储 `100,500,000`。
* **优势** : 保证了资产结算的绝对精确，且整数运算在 CPU 层面比浮点数更快。

### 2.2 零拷贝状态分发 (Zero-Copy State Distribution)

* **挑战** : 每秒更新 10 次，每次需将全量市场数据同步给 1000 个 Agent。如果使用消息队列或深拷贝，内存带宽将成为瓶颈。
* **实现** :  **Copy-on-Write (CoW) 变体** 。
* 主线程构建 `MarketSharedState`。
* 将其包装为 `Arc<MarketSharedState>` (原子引用计数智能指针)。
* 1000 个 Agent 持有该指针的克隆（仅增加引用计数，不复制数据）。

### 2.3 惰性删除撮合堆 (Lazy Deletion Heap)

* **挑战** : 标准二叉堆 (Binary Heap) 查找并删除非堆顶元素的时间复杂度是 O(N)。在高频撤单场景下，这将导致性能灾难。
* **实现** :
* **撤单** : 仅在 `HashSet` 中记录 OrderID，**不**操作堆。复杂度 O(1)。
* **撮合/查询** : 当访问堆顶元素时，检查其 ID 是否在 `HashSet` 中。若是，则弹出并丢弃，直到堆顶有效。
* **优势** : 将撤单操作的均摊复杂度从 O(N) 优化至  **O(log N)** 。

## 3. 模块化详细设计 (Module Design Specification)

本项目采用 **Workspace** 或 **Single Crate Multi-Binary** 结构。以下是各核心模块的深度定义。

### 3.1 模块 A: `domain` (领域内核)

这是系统的基石，定义了所有“名词”。

* **核心职责** : 定义数据结构、类型别名、常量和定点数运算规则。
* **依赖限制** :  **严禁依赖任何其他模块** 。它是最底层的叶子节点。
* **实现细节与技巧** :
* **NewType Pattern** : 不要直接使用 `i64` 代表价格，而是封装为 `struct Price(i64)` 和 `struct Amount(u64)`。利用 Rust 的类型系统防止将“价格”和“数量”相加的低级错误。
* **Serde Derives** : 为所有结构体添加 `#[derive(Serialize, Deserialize)]`，以便于后续的数据记录和 JSON 交互。
* **Atomic IDs** : 考虑使用 `AtomicU64` 实现全局唯一的 Order ID 生成器，避免锁竞争。
* **包含文件** :
* `fixed.rs`: 定点数转换逻辑。
* `types.rs`: `Order`, `Trade`, `Action` 等定义。

### 3.2 模块 B: `engine` (撮合引擎)

这是系统的“交易大厅”。

* **核心职责** : 维护订单簿 (OrderBook)，接收订单请求，输出成交回报 (MatchResult)。
* **依赖限制** : 仅依赖 `domain`。**不依赖** 脚本、Agent 或 IO。
* **实现细节与技巧** :
* **双堆结构** : `bids` (Max-Heap) 和 `asks` (Min-Heap)。
* **Result Enum** : `match_order` 函数不应打印日志，而应返回 `enum MatchResult { Filled(Trade), Partial(Trade, Remaining), Placed }`。
* **内存预分配** : `BinaryHeap` 和 `Vec` 应使用 `with_capacity` 进行初始化，减少运行时的内存重分配 (Re-allocation)。
* **包含文件** :
* `orderbook.rs`: 核心逻辑。

### 3.3 模块 C: `scripting` (脚本接口层)

这是系统的“翻译官”和“计算器”。

* **核心职责** : 将 Rust 的高性能算力和数据结构暴露给 Rhai 解释器。
* **依赖限制** : 依赖 `domain` 和 `rhai` crate。
* **实现细节与技巧** :
* **Math Lib (SIMD)** : 在 `math.rs` 中，不要写普通的 iterator，尽量利用 Rust 编译器对 `slice` 操作的自动向量化优化。暴露如 `sum`, `mean`, `slope` (线性回归) 等原子算子。
* **API 隔离** : 使用 `rhai::CustomType` trait 注册 `MarketState`。 **只暴露 Getter，不暴露 Setter** ，确保脚本无法修改市场价格（Read-Only Sandbox）。
* **AST 缓存** : 编译后的脚本 (`AST`) 必须被缓存，严禁在主循环中重复解析字符串。
* **包含文件** :
* `api.rs`: 类型注册。
* `math.rs`: 数学库。

### 3.4 模块 D: `simulation` (应用运行时)

这是系统的“上帝”和“总指挥”。

* **核心职责** : 初始化世界、管理 1000 个 Agent 的生命周期、控制时间流逝、调度并发。
* **依赖限制** : 依赖所有模块 (`domain`, `engine`, `scripting`)。
* **实现细节与技巧** :
* **Rayon Par-Iter** : 使用 `rayon::prelude::*` 对 Agent 集合进行 `par_iter_mut()`。这是实现单机高并发的核心。
* **确定性洗牌** : 使用 `rand_xoshiro` 或 `rand_chacha` 算法，并固定 Seed。**必须**在主线程完成 Shuffle，不要在并行线程中做，以保证顺序的确定性。
* **Double Buffering (双缓冲)** : 虽然我们用 Arc 共享状态，但在更新 `AgentAccount` 时，实际上是原位修改 (Interior Mutability is avoided per agent)。Agent 自身是 `mut` 的，因为它们被分配到了不同的线程中 (Ownership sharding)。
* **包含文件** :
* `environment.rs`: 主循环。
* `agent.rs`: 封装 Rhai Engine 和 Memory。
* `state.rs`: 全局状态管理。

### 3.5 模块 E: `record` (IO 黑匣子)

这是系统的“记官”。

* **核心职责** : 将仿真产生的数据持久化到磁盘。
* **依赖限制** : 依赖 `domain` 和 `csv` crate。
* **实现细节与技巧** :
* **Async Channel** : 使用 `std::sync::mpsc::sync_channel(10000)` (有界通道) 连接主线程和 IO 线程。
* **Backpressure** : 如果通道满了（IO 写不过来），主线程会阻塞。这是一种背压机制，防止内存爆掉。
* **BufWriter** : 必须使用 `std::io::BufWriter` 包装文件句柄，大幅减少系统调用 (Syscall) 次数。
* **包含文件** :
* `logger.rs`: CSV 写入逻辑。

### 3.6 工具 F: `generator` (造物主 - bin)

* **核心职责** : 调用 DeepSeek API，生成并校验代码。
* **实现技巧** :
* **Pre-Flight Check** : 生成代码后，立即在内存中调用 `rhai::Engine::compile()`。如果编译报错，直接丢弃重试， **绝不保存垃圾代码** 。
* **Semaphore** : 使用 `tokio::sync::Semaphore` 限制并发请求数，防止触发 API Rate Limit。

### 3.7 工具 G: `tui` (可视化 - bin 模块)

* **核心职责** : 终端实时展示。
* **实现技巧** :
* **Non-blocking Input** : 键盘监听必须是非阻塞的 (`crossterm::event::poll`)。
* **UI/Logic Decoupling** : UI 渲染频率 (e.g., 10fps) 应独立于模拟频率 (e.g., 1000tps)。不要让绘图拖慢计算。

## 4. 经济模型与 Agent 行为规范

### 4.1 交易费用 (Friction)

* **全局参数** : `FEE_RATE` (e.g., 0.0003)。
* **计算** : `Cost = Price * Amount * FEE_RATE`。

### 4.2 生命周期 (Lifecycle)

1. **初始化 (Setup)** :

* Agent 首次运行时，通过 `if !memory.contains("initialized")` 执行一次性配置。
* **底仓** : 初始化时分配随机持仓。

1. **预热期 (Warm-up)** :

* 前 N 个 Tick。
* **Feature** : 撮合引擎关闭。
* **Agent** : 只能观察，禁止下单。

1. **正式交易 (Trading)** : 全功能开放。

## 5. 数据流全景图 (Data Flow Pipeline)

```
[Init] Load Scripts -> Compile ASTs -> Init 1000 Agents

[Loop Start: Tick T]
   |
   +-> [Main Thread] Calculate Indicators (MA, VWAP, Slope) 
   |       |-> Wrap into Arc<MarketSharedState> (Zero-Copy)
   |
   +-> [Worker Threads (Rayon)] Parallel Execution
   |       |-> Agent 1: Read Arc<State> -> Run AST -> Write Decision
   |       |-> ...
   |       |-> Agent N: Read Arc<State> -> Run AST -> Write Decision
   |
   +-> [Main Thread] Collect Decisions -> Shuffle (Seed RNG) -> Vector<Order>
   |
   +-> [Main Thread] Matching Engine Processing
   |       |-> Lazy Deletion Check
   |       |-> Match / Update Book
   |       |-> Update AgentAccount
   |
   +-> [IO Thread] Async Channel -> BufWriter -> CSV
   |
   +-> [UI Thread] Render TUI (Ratatui)
   |
[Loop End: T = T + 1]
```
